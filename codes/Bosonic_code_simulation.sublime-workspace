{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"GKP",
				"GKP1DMAfterDecoding\tinstance"
			],
			[
				"Data",
				"DataState\tinstance"
			],
			[
				"Dara",
				"DataDMAfterDecoding\tinstance"
			],
			[
				"GKP1",
				"GKP1DMAfterDecoding\tinstance"
			],
			[
				"Measure",
				"MeasuredPositionNoise"
			],
			[
				"Posi",
				"PositionMeasurementOper\tinstance"
			],
			[
				"Sum",
				"SumGate\tinstance"
			],
			[
				"Sys",
				"SystemStateAfterEnconding\tinstance"
			],
			[
				"Plot",
				"PlotWignerState\tfunction"
			],
			[
				"dATA",
				"DataStateAfterEnconding"
			],
			[
				"pLOT",
				"PlotWignerDM"
			],
			[
				"Create",
				"CreateGKPState\tfunction"
			],
			[
				"plot",
				"Plot_wigner_state"
			],
			[
				"Error",
				"Error_syndrome2"
			],
			[
				"Seu",
				"Squeezed_dm"
			],
			[
				"Squee",
				"Squeezed_state"
			],
			[
				"Fock",
				"Fock_dm"
			],
			[
				"Foc",
				"Fock_state"
			],
			[
				"Co",
				"Co_state1"
			],
			[
				"Cat",
				"Cat_dm"
			]
		]
	},
	"buffers":
	[
		{
			"file": "/Users/qian/Documents/Sublime/Python/Simulation_of_QECC.py",
			"settings":
			{
				"buffer_size": 2717,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "PlotWignerDM.py",
			"settings":
			{
				"buffer_size": 346,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "PlotWignerState.py",
			"settings":
			{
				"buffer_size": 390,
				"line_ending": "Unix"
			}
		},
		{
			"file": "CreateGKPState.py",
			"settings":
			{
				"buffer_size": 351,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "\n(stderr):\nERROR:root:Invalid alias: The name clear can't be aliased because it is another magic command.\n\n(stderr):\nERROR:root:Invalid alias: The name more can't be aliased because it is another magic command.\n\n(stderr):\nERROR:root:Invalid alias: The name less can't be aliased because it is another magic command.\n\n(stderr):\nERROR:root:Invalid alias: The name man can't be aliased because it is another magic command.\n",
			"settings":
			{
				"buffer_size": 420,
				"line_ending": "Unix",
				"name": "*Hermes Output* Hermes_python3 ([python3] 7107690b-fe0c-4829-ac5a-2a5a935b5801)",
				"read_only": true,
				"scratch": true
			}
		},
		{
			"contents": "\n\nIn[1]: import sys\nsys.path.append('/Users/qian/Documents/Research/JiangGroupProjects/QEC_with_bosinic_code/codes')\n\n\nIn[2]: import numpy as np \nfrom qutip import *\nimport matplotlib.pyplot as plt \nimport matplotlib as mpl\nfrom matplotlib import cm\nfrom PlotWignerState import *\nfrom PlotWignerDM import *\nfrom CreateGKPState import *\n%matplotlib inline\n\n\nIn[3]: #Create GKP code\nDims = 100\nSum_num = 10\nGKP1 = CreateGKPState(Dims,Sum_num)\nPlotWignerState(GKP1)\n\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[4]: \n# Test of tensor product\nDataState = coherent(Dims, 2/np.sqrt(2))\nPlotWignerState(DataState)\n\nSystemState = tensor(DataState, GKP1)\nPlotWignerDM(ptrace(SystemState,0))\n\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[5]: \n# Test of tensor product\nDataState = coherent(Dims, 2/np.sqrt(2))\nPlotWignerState(DataState)\n\nSystemState = tensor(DataState, GKP1)\nPlotWignerDM(ptrace(SystemState,1))\n\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[6]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\n\n\n\nError[None]: KeyboardInterrupt, .\nTraceback:\n---------------------------------------------------------------------------\nKeyboardInterrupt                         Traceback (most recent call last)\n<ipython-input-6-f1e34769fdaa> in <module>\n      4 InitialSystemState = tensor(DataState, GKP1)\n      5 \n----> 6 SumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\n      7 \n      8 \n\n~/anaconda2/envs/python37/lib/python3.7/site-packages/qutip/qobj.py in expm(self, method)\n   1097 \n   1098         if method == 'dense':\n-> 1099             F = sp_expm(self.data, sparse=False)\n   1100 \n   1101         elif method == 'sparse':\n\n~/anaconda2/envs/python37/lib/python3.7/site-packages/qutip/sparse.py in sp_expm(A, sparse)\n    393         E = spla.expm(A.tocsc())\n    394     else:\n--> 395         E = spla.expm(A.toarray())\n    396     return sp.csr_matrix(E)\n    397 \n\n~/anaconda2/envs/python37/lib/python3.7/site-packages/scipy/sparse/linalg/matfuncs.py in expm(A)\n    604             [  0.        ,   0.        ,  20.08553692]])\n    605     \"\"\"\n--> 606     return _expm(A, use_exact_onenorm='auto')\n    607 \n    608 \n\n~/anaconda2/envs/python37/lib/python3.7/site-packages/scipy/sparse/linalg/matfuncs.py in _expm(A, use_exact_onenorm)\n    651 \n    652     # Try Pade order 5.\n--> 653     eta_2 = max(h.d4_tight, h.d6_loose)\n    654     if eta_2 < 2.539398330063230e-001 and _ell(h.A, 5) == 0:\n    655         U, V = h.pade5()\n\n~/anaconda2/envs/python37/lib/python3.7/site-packages/scipy/sparse/linalg/matfuncs.py in d4_tight(self)\n    432     def d4_tight(self):\n    433         if self._d4_exact is None:\n--> 434             self._d4_exact = _onenorm(self.A4)**(1/4.)\n    435         return self._d4_exact\n    436 \n\n~/anaconda2/envs/python37/lib/python3.7/site-packages/scipy/sparse/linalg/matfuncs.py in A4(self)\n    405         if self._A4 is None:\n    406             self._A4 = _smart_matrix_product(\n--> 407                     self.A2, self.A2, structure=self.structure)\n    408         return self._A4\n    409 \n\n~/anaconda2/envs/python37/lib/python3.7/site-packages/scipy/sparse/linalg/matfuncs.py in _smart_matrix_product(A, B, alpha, structure)\n    179     else:\n    180         if alpha is None:\n--> 181             out = A.dot(B)\n    182         else:\n    183             out = alpha * A.dot(B)\n\nKeyboardInterrupt: ",
			"settings":
			{
				"buffer_size": 3709,
				"line_ending": "Unix",
				"name": "*Hermes Output* Hermes_python3 ([python3] bfeb5fe9-99f2-4387-ad25-4c33bd6941da)",
				"read_only": true,
				"scratch": true
			}
		},
		{
			"contents": "\n\nIn[2]: import sys\nsys.path.append('/Users/qian/Documents/Research/JiangGroupProjects/QEC_with_bosinic_code/codes')\n\n\nIn[3]: import numpy as np \nfrom qutip import *\nimport matplotlib.pyplot as plt \nimport matplotlib as mpl\nfrom matplotlib import cm\nfrom PlotWignerState import *\nfrom PlotWignerDM import *\nfrom CreateGKPState import *\n%matplotlib inline\n\n\nIn[4]: #Create GKP code\nDims = 20\nSum_num = 4\n\nGKP1 = CreateGKPState(Dims,Sum_num)\nPlotWignerState(GKP1)\n\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[5]: #Create GKP code\nDims = 20\nSum_num = 2\n\nGKP1 = CreateGKPState(Dims,Sum_num)\nPlotWignerState(GKP1)\n\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[6]: #Create GKP code\nDims = 30\nSum_num = 4\n\nGKP1 = CreateGKPState(Dims,Sum_num)\nPlotWignerState(GKP1)\n\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[7]: #Create GKP code\nDims = 30\nSum_num = 6\n\nGKP1 = CreateGKPState(Dims,Sum_num)\nPlotWignerState(GKP1)\n\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[8]: #Create GKP code\nDims = 20\nSum_num = 4\n\nGKP1 = CreateGKPState(Dims,Sum_num)\nPlotWignerState(GKP1)\n\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[9]: #  Define stablizer operators\nS1 = (1j*np.sqrt(2*np.pi)*position(Dims)).expm()\nS2 = (- 1j*np.sqrt(2*np.pi)*momentum(Dims)).expm()\n\n#  Deine Noise operators\ndelta_pos = 0.3\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\n\n\nIn[10]: #  Define stablizer operators\nS1 = (1j*np.sqrt(2*np.pi)*position(Dims)).expm()\nS2 = (- 1j*np.sqrt(2*np.pi)*momentum(Dims)).expm()\n\n#  Deine Noise operators\ndelta_pos = 0.3\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\n\n# Syndrome measurement\nGKP_state_final = Position_Noise*GKP_state\nError_syndrome1 = (GKP_state_final.dag()*S1*GKP_state_final).full()\nError_syndrome1 = np.angle(Error_syndrome1[0,0])\nError_syndrome2 = (GKP_state_final.dag()*S2*GKP_state_final).full()\nError_syndrome2 = np.angle(Error_syndrome2[0,0])\n\nprint('Error Syndrome1:', Error_syndrome1/(np.sqrt(2*np.pi)), 'Error Syndrome2:', Error_syndrome2/(np.sqrt(2*np.pi)))\nprint(GKP_state.dag()*S2*GKP_state)\n\n\nError[None]: NameError, name 'GKP_state' is not defined.\nTraceback:\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n<ipython-input-10-26cdc49eb6e3> in <module>\n      8 \n      9 # Syndrome measurement\n---> 10 GKP_state_final = Position_Noise*GKP_state\n     11 Error_syndrome1 = (GKP_state_final.dag()*S1*GKP_state_final).full()\n     12 Error_syndrome1 = np.angle(Error_syndrome1[0,0])\n\nNameError: name 'GKP_state' is not defined\n\nIn[11]: #Create GKP code\nDims = 20\nSum_num = 4\n\nGKP_state = CreateGKPState(Dims,Sum_num)\nPlotWignerState(GKP_state)\n\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[12]: #  Define stablizer operators\nS1 = (1j*np.sqrt(2*np.pi)*position(Dims)).expm()\nS2 = (- 1j*np.sqrt(2*np.pi)*momentum(Dims)).expm()\n\n#  Deine Noise operators\ndelta_pos = 0.3\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\n\n# Syndrome measurement\nGKP_state_final = Position_Noise*GKP_state\nError_syndrome1 = (GKP_state_final.dag()*S1*GKP_state_final).full()\nError_syndrome1 = np.angle(Error_syndrome1[0,0])\nError_syndrome2 = (GKP_state_final.dag()*S2*GKP_state_final).full()\nError_syndrome2 = np.angle(Error_syndrome2[0,0])\n\nprint('Error Syndrome1:', Error_syndrome1/(np.sqrt(2*np.pi)), 'Error Syndrome2:', Error_syndrome2/(np.sqrt(2*np.pi)))\nprint(GKP_state.dag()*S2*GKP_state)\n\n\n(stdout):\nError Syndrome1: 0.29814652391730045 Error Syndrome2: 0.0\nQuantum object: dims = [[1], [1]], shape = (1, 1), type = bra\nQobj data =\n[[0.38561171]]\n\n\nIn[13]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,0)\nPlotWignerDM(DataStateAfterEnconding)\n\n\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[14]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,0)\nPlotWignerState(GKP1)\nPlotWignerDM(DataStateAfterEnconding)\n\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[15]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\nPlotWignerState(GKP1)\nPlotWignerDM(DataStateAfterEnconding)\n\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[16]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,0)\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDeconding = DifferenceGate*SystemStateAfterEnconding\nDataStateAfterDeconding = ptrace(SystemStateAfterDeconding,0)\n\nPlotWignerState(GKP1)\nPlotWignerDM(DataStateAfterDeconding)\n\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[17]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,0)\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDeconding = DifferenceGate*SystemStateAfterEnconding\nDataStateAfterDeconding = ptrace(SystemStateAfterDeconding,1)\n\nPlotWignerState(GKP1)\nPlotWignerDM(DataStateAfterDeconding)\n\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[18]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDeconding = DifferenceGate*SystemStateAfterEnconding\nDataStateAfterDeconding = SystemStateAfterDeconding.ptrace(0)\n\nPlotWignerState(GKP1)\nPlotWignerDM(DataStateAfterDeconding)\n\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[19]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDeconding = DifferenceGate*SystemStateAfterEnconding\nDataStateAfterDeconding = SystemStateAfterDeconding.ptrace(1)\n\nPlotWignerState(GKP1)\nPlotWignerDM(DataStateAfterDeconding)\n\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[20]: #  Define stablizer operators\nS1 = (1j*np.sqrt(2*np.pi)*position(Dims)).expm()\nS2 = (- 1j*np.sqrt(2*np.pi)*momentum(Dims)).expm()\nPositionMeasurementOper = S1\n\n#  Deine Noise operators\ndelta_pos = 0.3\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\n\n# Syndrome measurement\nGKP_state_final = Position_Noise*GKP_state\nError_syndrome1 = (GKP_state_final.dag()*S1*GKP_state_final).full()\nError_syndrome1 = np.angle(Error_syndrome1[0,0])\nError_syndrome2 = (GKP_state_final.dag()*S2*GKP_state_final).full()\nError_syndrome2 = np.angle(Error_syndrome2[0,0])\n\nprint('Error Syndrome1:', Error_syndrome1/(np.sqrt(2*np.pi)), 'Error Syndrome2:', Error_syndrome2/(np.sqrt(2*np.pi)))\nprint(GKP_state.dag()*S2*GKP_state)\n\n\n(stdout):\nError Syndrome1: 0.29814652391730045 Error Syndrome2: 0.0\nQuantum object: dims = [[1], [1]], shape = (1, 1), type = bra\nQobj data =\n[[0.38561171]]\n\n\nIn[21]: # Measure the qudrature noise\nMeasurementOutcome1 = trace(DataDMAfterDeconding*PositionMeasurementOper)\n\n\nError[None]: NameError, name 'trace' is not defined.\nTraceback:\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n<ipython-input-21-fedeef5e0a43> in <module>\n      1 # Measure the qudrature noise\n----> 2 MeasurementOutcome1 = trace(DataDMAfterDeconding*PositionMeasurementOper)\n      3 \n\nNameError: name 'trace' is not defined\n\nIn[22]: # Measure the qudrature noise\nMeasurementOutcome1 = (DataDMAfterDeconding*PositionMeasurementOper).norm()\n\n\nError[None]: NameError, name 'DataDMAfterDeconding' is not defined.\nTraceback:\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n<ipython-input-22-309f01d972c1> in <module>\n      1 # Measure the qudrature noise\n----> 2 MeasurementOutcome1 = (DataDMAfterDeconding*PositionMeasurementOper).norm()\n      3 \n\nNameError: name 'DataDMAfterDeconding' is not defined\n\nIn[23]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDeconding = DifferenceGate*SystemStateAfterEnconding\nDataDMAfterDeconding = SystemStateAfterDeconding.ptrace(1)\n\nPlotWignerState(GKP1)\nPlotWignerDM(DataDMAfterDeconding)\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[24]: # Measure the qudrature noise\nMeasurementOutcome1 = (DataDMAfterDeconding*PositionMeasurementOper).norm()\n\n\n\nIn[25]: # Measure the qudrature noise\nMeasurementOutcome1 = (DataDMAfterDeconding*PositionMeasurementOper).norm()\nMeasurementOutcome1\n\n\n(display data): 1.0000000486726475\n\nIn[26]: # Measure the qudrature noise\nMeasurementOutcome1 = (DataDMAfterDeconding*PositionMeasurementOper).norm()\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*np.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\nMeasured Position Noise: 0.0\n\n\nIn[27]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Through the noisy channel\ndelta_pos = 0.3\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\nNoiseOperator =  tensor(Position_Noise, identity(Dims)) # Only include the position shift noise on the data mode for now\nSystemStateAfterNoise = NoiseOperator*SystemStateAfterEnconding\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDeconding = DifferenceGate*SystemStateAfterNoise\nDataDMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\nGKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\n\nPlotWignerState(GKP1)\nPlotWignerDM(DataDMAfterDeconding)\n\nError[None]: NameError, name 'SystemStateAfterDecoding' is not defined.\nTraceback:\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n<ipython-input-27-017924b24d18> in <module>\n     18 DifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\n     19 SystemStateAfterDeconding = DifferenceGate*SystemStateAfterNoise\n---> 20 DataDMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\n     21 GKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\n     22 \n\nNameError: name 'SystemStateAfterDecoding' is not defined\n\nIn[28]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Through the noisy channel\ndelta_pos = 0.3\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\nNoiseOperator =  tensor(Position_Noise, identity(Dims)) # Only include the position shift noise on the data mode for now\nSystemStateAfterNoise = NoiseOperator*SystemStateAfterEnconding\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDecoding = DifferenceGate*SystemStateAfterNoise\nDataDMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\nGKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\n\nPlotWignerState(GKP1)\nPlotWignerDM(DataDMAfterDeconding)\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[29]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Through the noisy channel\ndelta_pos = 0.3\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\nNoiseOperator =  tensor(Position_Noise, identity(Dims)) # Only include the position shift noise on the data mode for now\nSystemStateAfterNoise = NoiseOperator*SystemStateAfterEnconding\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDecoding = DifferenceGate*SystemStateAfterNoise\nDataDMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\nGKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\n\nPlotWignerState(GKP1)\nPlotWignerDM(GKP1DMAfterDeconding)\n\n(display data): <Figure size 432x288 with 2 Axes>\nError[None]: NameError, name 'GKP1DMAfterDeconding' is not defined.\nTraceback:\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n<ipython-input-29-6f90ed5e0a6e> in <module>\n     22 \n     23 PlotWignerState(GKP1)\n---> 24 PlotWignerDM(GKP1DMAfterDeconding)\n\nNameError: name 'GKP1DMAfterDeconding' is not defined\n\nIn[30]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Through the noisy channel\ndelta_pos = 0.3\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\nNoiseOperator =  tensor(Position_Noise, identity(Dims)) # Only include the position shift noise on the data mode for now\nSystemStateAfterNoise = NoiseOperator*SystemStateAfterEnconding\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDecoding = DifferenceGate*SystemStateAfterNoise\nDataDMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\nGKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\n\nPlotWignerState(GKP1)\nPlotWignerDM(GKP1DMAfterDecoding)\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[31]: # Measure the qudrature noise\nMeasurementOutcome1 = (GKP1DMAfterDecoding*PositionMeasurementOper).norm()\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*np.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\nMeasured Position Noise: 0.0\n\n\nIn[32]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Through the noisy channel\ndelta_pos = 0.3\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\nNoiseOperator =  tensor(Position_Noise, identity(Dims)) # Only include the position shift noise on the data mode for now\nSystemStateAfterNoise = NoiseOperator*SystemStateAfterEnconding\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDecoding = DifferenceGate*SystemStateAfterNoise\nDataDMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\nGKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\n\nPlotWignerState(DataState)\nPlotWignerDM(GKP1DMAfterDecoding)\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[33]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Through the noisy channel\ndelta_pos = 0.3\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\nNoiseOperator =  tensor(Position_Noise, identity(Dims)) # Only include the position shift noise on the data mode for now\nSystemStateAfterNoise = NoiseOperator*SystemStateAfterEnconding\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDecoding = DifferenceGate*SystemStateAfterNoise\nDataDMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\nGKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\n\nPlotWignerState(DataState)\nPlotWignerDM(GKP1DMAfterDecoding)\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[34]: # Measure the qudrature noise\nMeasurementOutcome1 = (GKP1DMAfterDecoding*PositionMeasurementOper).norm()\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*np.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\nMeasured Position Noise: 0.0\n\n\nIn[35]: # Measure the qudrature noise\nMeasurementOutcome1 = (GKP1DMAfterDecoding*PositionMeasurementOper).norm()\nMeasurementOutcome1\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*np.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\nMeasured Position Noise: 0.0\n\n\nIn[36]: # Measure the qudrature noise\nMeasurementOutcome1 = (GKP1DMAfterDecoding*PositionMeasurementOper).norm()\nprint(MeasurementOutcome1)\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*np.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\n1.0000000268943419\nMeasured Position Noise: 0.0\n\n\nIn[37]: #  Define stablizer operators\nS1 = (1j*np.sqrt(2*np.pi)*position(Dims)).expm()\nS2 = (- 1j*np.sqrt(2*np.pi)*momentum(Dims)).expm()\nPositionMeasurementOper = S2\n\n#  Deine Noise operators\ndelta_pos = 0.3\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\n\n# Syndrome measurement\nGKP_state_final = Position_Noise*GKP_state\nError_syndrome1 = (GKP_state_final.dag()*S1*GKP_state_final).full()\nError_syndrome1 = np.angle(Error_syndrome1[0,0])\nError_syndrome2 = (GKP_state_final.dag()*S2*GKP_state_final).full()\nError_syndrome2 = np.angle(Error_syndrome2[0,0])\n\nprint('Error Syndrome1:', Error_syndrome1/(np.sqrt(2*np.pi)), 'Error Syndrome2:', Error_syndrome2/(np.sqrt(2*np.pi)))\nprint(GKP_state.dag()*S2*GKP_state)\n\n\n(stdout):\nError Syndrome1: 0.29814652391730045 Error Syndrome2: 0.0\nQuantum object: dims = [[1], [1]], shape = (1, 1), type = bra\nQobj data =\n[[0.38561171]]\n\n\nIn[38]: # Measure the qudrature noise\nMeasurementOutcome1 = (GKP1DMAfterDecoding*PositionMeasurementOper).norm()\nprint(MeasurementOutcome1)\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*np.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\n1.000000027166933\nMeasured Position Noise: 0.0\n\n\nIn[39]: #  Define stablizer operators\nS1 = (1j*np.sqrt(2*np.pi)*position(Dims)).expm()\nS2 = (- 1j*np.sqrt(2*np.pi)*momentum(Dims)).expm()\nPositionMeasurementOper = S1\n\n#  Deine Noise operators\ndelta_pos = 0.3\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\n\n# Syndrome measurement\nGKP_state_final = Position_Noise*GKP_state\nError_syndrome1 = (GKP_state_final.dag()*S1*GKP_state_final).full()\nError_syndrome1 = np.angle(Error_syndrome1[0,0])\nError_syndrome2 = (GKP_state_final.dag()*S2*GKP_state_final).full()\nError_syndrome2 = np.angle(Error_syndrome2[0,0])\n\nprint('Error Syndrome1:', Error_syndrome1/(np.sqrt(2*np.pi)), 'Error Syndrome2:', Error_syndrome2/(np.sqrt(2*np.pi)))\nprint(GKP_state.dag()*S2*GKP_state)\n\n\n(stdout):\nError Syndrome1: 0.29814652391730045 Error Syndrome2: 0.0\nQuantum object: dims = [[1], [1]], shape = (1, 1), type = bra\nQobj data =\n[[0.38561171]]\n\n\nIn[40]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Through the noisy channel\ndelta_pos = 0.3\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\nNoiseOperator =  tensor(Position_Noise, identity(Dims)) # Only include the position shift noise on the data mode for now\nSystemStateAfterNoise = NoiseOperator*SystemStateAfterEnconding\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDecoding = DifferenceGate*SystemStateAfterNoise\nDataDMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\nGKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\n\nPlotWignerState(DataState)\nPlotWignerDM(GKP1DMAfterDecoding)\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[41]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Through the noisy channel\ndelta_pos = 0.3\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\nNoiseOperator =  tensor(Position_Noise, identity(Dims)) # Only include the position shift noise on the data mode for now\nSystemStateAfterNoise = NoiseOperator*SystemStateAfterEnconding\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDecoding = DifferenceGate*SystemStateAfterNoise\nDataDMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\nGKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\n\nPlotWignerState(GKP_state)\nPlotWignerDM(GKP1DMAfterDecoding)\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[42]: #  Define stablizer operators\nS1 = (1j*np.sqrt(2*np.pi)*position(Dims)).expm()\nS2 = (- 1j*np.sqrt(2*np.pi)*momentum(Dims)).expm()\nPositionMeasurementOper = S1\n\n#  Deine Noise operators\ndelta_pos = 0.3\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\n\n# Syndrome measurement\nGKP_state_final = Position_Noise*GKP_state\nError_syndrome1 = (GKP_state_final.dag()*S1*GKP_state_final).full()\nError_syndrome1 = np.angle(Error_syndrome1[0,0])\nError_syndrome2 = (GKP_state_final.dag()*S2*GKP_state_final).full()\nError_syndrome2 = np.angle(Error_syndrome2[0,0])\n\nPlotWignerState(GKP1)\nPlotWignerState(GKP_state_final)\n\nprint('Error Syndrome1:', Error_syndrome1/(np.sqrt(2*np.pi)), 'Error Syndrome2:', Error_syndrome2/(np.sqrt(2*np.pi)))\nprint(GKP_state.dag()*S2*GKP_state)\n\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n(stdout):\nError Syndrome1: 0.29814652391730045 Error Syndrome2: 0.0\nQuantum object: dims = [[1], [1]], shape = (1, 1), type = bra\nQobj data =\n[[0.38561171]]\n\n\nIn[43]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Through the noisy channel\ndelta_pos = 0.2\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\nNoiseOperator =  tensor(Position_Noise, identity(Dims)) # Only include the position shift noise on the data mode for now\nSystemStateAfterNoise = NoiseOperator*SystemStateAfterEnconding\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDecoding = DifferenceGate*SystemStateAfterNoise\nDataDMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\nGKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\n\nPlotWignerState(GKP_state)\nPlotWignerDM(GKP1DMAfterDecoding)\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[44]: # Measure the qudrature noise\nMeasurementOutcome1 = (PositionMeasurementOper*GKP1DMAfterDecoding).norm()\nprint(MeasurementOutcome1)\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*np.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\n1.0000000268200133\nMeasured Position Noise: 0.0\n\n\nIn[45]: # Measure the qudrature noise\nMeasurementOutcome1 = (PositionMeasurementOper).norm()\nprint(MeasurementOutcome1)\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*np.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\n19.999999999999996\nMeasured Position Noise: 0.0\n\n\nIn[46]: # Measure the qudrature noise\nMeasurementOutcome1 = (PositionMeasurementOper*DataDMAfterDecoding).norm()\nprint(MeasurementOutcome1)\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*np.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\n1.0000000234575739\nMeasured Position Noise: 0.0\n\n\nIn[47]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Through the noisy channel\ndelta_pos = 0.2\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\nNoiseOperator =  tensor(Position_Noise, identity(Dims)) # Only include the position shift noise on the data mode for now\nSystemStateAfterNoise = NoiseOperator*SystemStateAfterEnconding\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDecoding = DifferenceGate*SystemStateAfterNoise\nDataDMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\nGKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\n\nPlotWignerState(GKP_state)\nPlotWignerDM(GKP1DMAfterDecoding)\nPlotWignerDM(DataDMAfterDecoding)\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[48]: print((position(Dims)*DataDMAfterDecoding).norm())\n\n(stdout):\n2.2594420829576385\n\n\nIn[49]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Through the noisy channel\ndelta_pos = 0.00001\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\nNoiseOperator =  tensor(Position_Noise, identity(Dims)) # Only include the position shift noise on the data mode for now\nSystemStateAfterNoise = NoiseOperator*SystemStateAfterEnconding\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDecoding = DifferenceGate*SystemStateAfterNoise\nDataDMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\nGKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\n\nPlotWignerState(GKP_state)\nPlotWignerDM(GKP1DMAfterDecoding)\nPlotWignerDM(DataDMAfterDecoding)\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[50]: print((position(Dims)*DataDMAfterDecoding).norm())\n\n(stdout):\n2.121323607475116\n\n\nIn[51]: print((position(Dims)*DataState*DataState.dag()).norm())\n\n(stdout):\n2.1213204618797015\n\n\nIn[52]: print((position(Dims)*GKP1*GKP1.dag()).norm())\n\n(stdout):\n3.2834169786104956\n\n\nIn[53]: print((position(Dims)*GKP1DMAfterDecoding).norm())\n\n(stdout):\n3.283418792095556\n\n\nIn[54]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Through the noisy channel\ndelta_pos = 0.2\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\nNoiseOperator =  tensor(Position_Noise, identity(Dims)) # Only include the position shift noise on the data mode for now\nSystemStateAfterNoise = NoiseOperator*SystemStateAfterEnconding\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDecoding = DifferenceGate*SystemStateAfterNoise\nDataDMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\nGKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\n\nPlotWignerState(GKP_state)\nPlotWignerDM(GKP1DMAfterDecoding)\nPlotWignerDM(DataDMAfterDecoding)\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[55]: # Measure the qudrature noise\nMeasurementOutcome1 = (PositionMeasurementOper*DataDMAfterDecoding).norm()\nprint(MeasurementOutcome1)\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*np.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\n1.0000000234575739\nMeasured Position Noise: 0.0\n\n\nIn[56]: print((position(Dims)*GKP1DMAfterDecoding).norm())\n\n(stdout):\n3.25218801813475\n\n\nIn[57]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Through the noisy channel\ndelta_pos = 0.5\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\nNoiseOperator =  tensor(Position_Noise, identity(Dims)) # Only include the position shift noise on the data mode for now\nSystemStateAfterNoise = NoiseOperator*SystemStateAfterEnconding\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDecoding = DifferenceGate*SystemStateAfterNoise\nDataDMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\nGKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\n\nPlotWignerState(GKP_state)\nPlotWignerDM(GKP1DMAfterDecoding)\nPlotWignerDM(DataDMAfterDecoding)\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[58]: print((position(Dims)*GKP1DMAfterDecoding).norm())\n\n(stdout):\n3.292287910787149\n\n\nIn[59]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Through the noisy channel\ndelta_pos = 0.3\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\nNoiseOperator =  tensor(Position_Noise, identity(Dims)) # Only include the position shift noise on the data mode for now\nSystemStateAfterNoise = NoiseOperator*SystemStateAfterEnconding\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDecoding = DifferenceGate*SystemStateAfterNoise\nDataDMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\nGKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\n\nPlotWignerState(GKP_state)\nPlotWignerDM(GKP1DMAfterDecoding)\nPlotWignerDM(DataDMAfterDecoding)\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[60]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Through the noisy channel\ndelta_pos = 0.5\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\nNoiseOperator =  tensor(Position_Noise, identity(Dims)) # Only include the position shift noise on the data mode for now\nSystemStateAfterNoise = NoiseOperator*SystemStateAfterEnconding\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDecoding = DifferenceGate*SystemStateAfterNoise\nDataDMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\nGKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\n\nPlotWignerState(GKP_state)\nPlotWignerDM(GKP1DMAfterDecoding)\nPlotWignerDM(DataDMAfterDecoding)\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[61]: # Measure the qudrature noise\nMeasurementOutcome1 = (PositionMeasurementOper*DataDMAfterDecoding).norm()\nprint(MeasurementOutcome1)\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*np.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\n1.0000000232567212\nMeasured Position Noise: 0.0\n\n\nIn[62]: # Measure the qudrature noise\nMeasurementOutcome1 = (S1*DataDMAfterDecoding).norm()\nprint(MeasurementOutcome1)\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*np.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\n1.0000000232567212\nMeasured Position Noise: 0.0\n\n\nIn[63]: # Measure the qudrature noise\nMeasurementOutcome1 = (S1*DataDMAfterDecoding).norm()\nprint(MeasurementOutcome1)\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\n1.0000000232567212\nMeasured Position Noise: 0.0\n\n\nIn[64]: print((position(Dims)*GKP1*GKP1.dag().norm())\nprint(GKP1.dag()*position(Dims)*GKP1)\n\nError[None]: SyntaxError, invalid syntax (<ipython-input-64-892bc72d7de5>, line 2).\nTraceback:\n  File \"<ipython-input-64-892bc72d7de5>\", line 2\n    print(GKP1.dag()*position(Dims)*GKP1)\n        ^\nSyntaxError: invalid syntax\n\n\nIn[65]: print((position(Dims)*GKP1*GKP1.dag()).norm())\nprint(GKP1.dag()*position(Dims)*GKP1)\n\n(stdout):\n3.2834169786104956\nQuantum object: dims = [[1], [1]], shape = (1, 1), type = bra\nQobj data =\n[[0.]]\n\n\nIn[66]: print((position(Dims)*GKP1*GKP1.dag()).norm())\nprint((GKP1.dag()*position(Dims)*GKP1)[0,0])\n\n(stdout):\n3.2834169786104956\n0j\n\n\nIn[67]: print((position(Dims)*GKP1*GKP1.dag()).tr())\nprint((GKP1.dag()*position(Dims)*GKP1)[0,0])\n\n(stdout):\n0.0\n0j\n\n\nIn[68]: # Measure the qudrature noise\nMeasurementOutcome1 = (S1*DataDMAfterDecoding).tr()\nprint(MeasurementOutcome1)\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\n(0.20054519624812078-0.006286227403246596j)\nMeasured Position Noise: -0.03133542904437545\n\n\nIn[69]: # Measure the qudrature noise\nMeasurementOutcome1 = (S1*DataDMAfterDecoding).tr()\nprint(MeasurementOutcome1)\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*ni.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\n(0.20054519624812078-0.006286227403246596j)\n\nError[None]: NameError, name 'ni' is not defined.\nTraceback:\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n<ipython-input-69-b298dcb74b62> in <module>\n      2 MeasurementOutcome1 = (S1*DataDMAfterDecoding).tr()\n      3 print(MeasurementOutcome1)\n----> 4 MeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*ni.pi)\n      5 print('Measured Position Noise:', MeasuredPositionNoise)\n      6 \n\nNameError: name 'ni' is not defined\n\nIn[70]: # Measure the qudrature noise\nMeasurementOutcome1 = (S1*DataDMAfterDecoding).tr()\nprint(MeasurementOutcome1)\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*np.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\n(0.20054519624812078-0.006286227403246596j)\nMeasured Position Noise: -0.01250102752032043\n\n\nIn[71]: # Measure the qudrature noise\nMeasurementOutcome1 = (S1*DataDMAfterDecoding).tr()\nprint(MeasurementOutcome1)\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)*np.sqrt(2*np.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\n(0.20054519624812078-0.006286227403246596j)\nMeasured Position Noise: -0.07854627244032497\n\n\nIn[72]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Through the noisy channel\ndelta_pos = 0.2\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\nNoiseOperator =  tensor(Position_Noise, identity(Dims)) # Only include the position shift noise on the data mode for now\nSystemStateAfterNoise = NoiseOperator*SystemStateAfterEnconding\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDecoding = DifferenceGate*SystemStateAfterNoise\nDataDMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\nGKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\n\nPlotWignerState(GKP_state)\nPlotWignerDM(GKP1DMAfterDecoding)\nPlotWignerDM(DataDMAfterDecoding)\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[73]: # Measure the qudrature noise\nMeasurementOutcome1 = (S1*DataDMAfterDecoding).tr()\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*np.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\nMeasured Position Noise: -0.3620432091849638\n\n\nIn[74]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Through the noisy channel\ndelta_pos = 0.1\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\nNoiseOperator =  tensor(Position_Noise, identity(Dims)) # Only include the position shift noise on the data mode for now\nSystemStateAfterNoise = NoiseOperator*SystemStateAfterEnconding\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDecoding = DifferenceGate*SystemStateAfterNoise\nDataDMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\nGKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\n\nPlotWignerState(GKP_state)\nPlotWignerDM(GKP1DMAfterDecoding)\nPlotWignerDM(DataDMAfterDecoding)\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[75]: # Measure the qudrature noise\nMeasurementOutcome1 = (S1*DataDMAfterDecoding).tr()\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*np.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\nMeasured Position Noise: -0.45558151283371673\n\n\nIn[76]: # Measure the qudrature noise\nMeasurementOutcome1 = (PositionMeasurementOper*GKP1DMAfterDecoding).tr()\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*np.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\nMeasured Position Noise: -0.11571464965189529\n\n\nIn[77]: # Create GKP stabilizer state\nDataState = coherent(Dims, 2/np.sqrt(2))\nGKP1 = CreateGKPState(Dims, Sum_num)\nInitialSystemState = tensor(DataState, GKP1)\n\n#encoding\nSumGate = (-1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterEnconding = SumGate*InitialSystemState\nDataStateAfterEnconding = ptrace(SystemStateAfterEnconding,1)\n\n# Through the noisy channel\ndelta_pos = 0.2\nPosition_Noise = (- 1j*delta_pos*momentum(Dims)).expm()\nNoiseOperator =  tensor(Position_Noise, identity(Dims)) # Only include the position shift noise on the data mode for now\nSystemStateAfterNoise = NoiseOperator*SystemStateAfterEnconding\n\n# Decoding\nDifferenceGate = (1j*tensor(position(Dims),identity(Dims))*tensor(identity(Dims),momentum(Dims))).expm()\nSystemStateAfterDecoding = DifferenceGate*SystemStateAfterNoise\nDataDMAfterDecoding = SystemStateAfterDecoding.ptrace(0)\nGKP1DMAfterDecoding = SystemStateAfterDecoding.ptrace(1)\n\nPlotWignerState(GKP_state)\nPlotWignerDM(GKP1DMAfterDecoding)\nPlotWignerDM(DataDMAfterDecoding)\n\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n(display data): <Figure size 432x288 with 2 Axes>\n\nIn[78]: # Measure the qudrature noise\nMeasurementOutcome1 = (PositionMeasurementOper*GKP1DMAfterDecoding).tr()\nMeasuredPositionNoise = np.angle(MeasurementOutcome1)/np.sqrt(2*np.pi)\nprint('Measured Position Noise:', MeasuredPositionNoise)\n\n\n(stdout):\nMeasured Position Noise: -0.21188008102138334\n",
			"settings":
			{
				"buffer_size": 44814,
				"line_ending": "Unix",
				"name": "*Hermes Output* Hermes_python3 ([python3] 76fbda45-563f-4a86-bd9c-23642684f3ab)",
				"read_only": true,
				"scratch": true
			}
		}
	],
	"build_system": "Packages/User/Python37.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					""
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Traditional"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"PdfLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"XeLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"LuaLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Basic Builder"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Basic Builder - PdfLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Basic Builder - XeLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Basic Builder - LuaLaTeX"
				],
				[
					"Packages/LaTeXTools/LaTeX.sublime-build",
					"Script Builder"
				]
			],
			[
				"Packages/LaTeXTools/LaTeX.sublime-build",
				"Traditional"
			]
		],
		[
			[
				[
					"Packages/Python/Python.sublime-build",
					""
				],
				[
					"Packages/Python/Python.sublime-build",
					"Syntax Check"
				]
			],
			[
				"Packages/Python/Python.sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/Python/Python.sublime-build",
					""
				],
				[
					"Packages/Python/Python.sublime-build",
					"Syntax Check"
				],
				[
					"Packages/User/Python27.sublime-build",
					""
				],
				[
					"Packages/User/Python3.sublime-build",
					""
				],
				[
					"Packages/User/Python37.sublime-build",
					""
				]
			],
			[
				"Packages/User/Python37.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"Her",
				"Hermes: Shutdown Kernel"
			],
			[
				"Hermes",
				"Hermes: Start Kernel"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"Hermes:",
				"Hermes: Connect Kernel"
			],
			[
				"remove",
				"Package Control: Remove Package"
			],
			[
				"instal",
				"Package Control: Install Package"
			],
			[
				"install ",
				"Package Control: Install Package"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/Users/qian/Documents/Research/JiangGroupProjects/QEC_with_bosinic_code/codes/CreateGKPState.py",
		"/Users/qian/Documents/Research/JiangGroupProjects/QEC_with_bosinic_code/codes/GKP_state.py",
		"/Users/qian/Documents/Sublime/Python/Simulation_of_QECC.py",
		"/Users/qian/Documents/Research/JiangGroupProjects/QEC_with_bosinic_code/codes/PlotWignerState.py",
		"/Users/qian/Library/Application Support/Sublime Text 3/Packages/Hermes/Hermes.sublime-settings",
		"/Users/qian/Documents/Sublime/Latex/NJUThesis2018-master/sample.tex",
		"/Users/qian/Documents/Sublime/Python/*Hermes Output* python3_hermes ([python3] 809cf7aa-c476-4e3e-aebe-564701b1b34c)",
		"/Users/qian/Documents/Sublime/Python/Hermes_test.py",
		"/Users/qian/Documents/Sublime/Python/test.py",
		"/Users/qian/Library/Application Support/Sublime Text 3/Packages/User/Python27.sublime-build",
		"/Users/qian/Documents/Sublime/Python/Test.sublime-project",
		"/Users/qian/Library/Application Support/Sublime Text 3/Packages/User/Anaconda.sublime-settings",
		"/Users/qian/Library/Application Support/Sublime Text 3/Packages/Anaconda/Anaconda.sublime-settings",
		"/Users/qian/Library/Application Support/Sublime Text 3/Packages/User/Python3.sublime-build",
		"/Users/qian/Library/Application Support/Sublime Text 3/Packages/User/Python37.sublime-build",
		"/Users/qian/Library/Application Support/Sublime Text 3/Packages/User/Python3.sublime-build "
	],
	"find":
	{
		"height": 39.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "/Users/qian/Documents/Sublime/Python/Simulation_of_QECC.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2717,
						"regions":
						{
						},
						"selection":
						[
							[
								348,
								348
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": ".",
									"selector": "source.python - string - comment - constant.numeric"
								},
								{
									"characters": ".",
									"selector": "source.python - string - constant.numeric"
								},
								{
									"characters": ".",
									"selector": "source.python - string - constant.numeric"
								}
							],
							"syntax": "Packages/Python/Python.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 110.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "PlotWignerDM.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 346,
						"regions":
						{
						},
						"selection":
						[
							[
								141,
								141
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": ".",
									"selector": "source.python - string - comment - constant.numeric"
								},
								{
									"characters": ".",
									"selector": "source.python - string - constant.numeric"
								}
							],
							"syntax": "Packages/Python/Python.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "PlotWignerState.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 390,
						"regions":
						{
						},
						"selection":
						[
							[
								390,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "CreateGKPState.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 351,
						"regions":
						{
						},
						"selection":
						[
							[
								350,
								350
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": ".",
									"selector": "source.python - string - comment - constant.numeric"
								},
								{
									"characters": ".",
									"selector": "source.python - string - constant.numeric"
								}
							],
							"syntax": "Packages/Python/Python.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				}
			]
		},
		{
			"selected": 2,
			"sheets":
			[
				{
					"buffer": 4,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 420,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"word_wrap": "false"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 5,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3709,
						"regions":
						{
						},
						"selection":
						[
							[
								1233,
								1233
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"word_wrap": "false"
						},
						"translation.x": 0.0,
						"translation.y": 2315.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 6,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 44814,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"word_wrap": "false"
						},
						"translation.x": 1.0,
						"translation.y": 35570.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 24.0
	},
	"input":
	{
		"height": 36.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.5,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 83.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.latextools":
	{
		"height": 108.0
	},
	"pinned_build_system": "Packages/User/Python3.sublime-build",
	"project": "Bosonic_code_simulation.sublime-project",
	"replace":
	{
		"height": 44.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": false,
	"side_bar_width": 113.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
